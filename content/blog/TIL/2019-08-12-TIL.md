---
title: 2019-08-12 TIL
date: 2019-08-12 23:00:23
category: TIL
---

2019-08-12

# React tips

Dan Abramov의 블로그를 읽다가 알게된 것들 간단히 갈무리

잘시간이라 번역과 정리는 다음에!!

쏟아놓고 보니 FAQ내용이 대부분인거같넹

## [How to create expensive objects lazily?]([https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily](https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily))

`useMemo`  lets you  [memoize an expensive calculation](https://reactjs.org/docs/hooks-faq.html#how-to-memoize-calculations)  if the dependencies are the same. However, it only serves as a hint, and doesn’t  _guarantee_  the computation won’t re-run. But sometimes you need to be sure an object is only created once.

**The first common use case is when creating the initial state is expensive:**

```jsx
function Table(props) {
  // ⚠️ createRows() is called on every render
  const [rows, setRows] = useState(createRows(props.count));
  // ...
}
```

To avoid re-creating the ignored initial state, we can pass a  **function**  to  `useState`:

```jsx
function Table(props) {
  // ✅ createRows() is only called once
  const [rows, setRows] = useState(() => createRows(props.count));
  // ...
}
```

React will only call this function during the first render. See the  [`useState`  API reference](https://reactjs.org/docs/hooks-reference.html#usestate).

**You might also occasionally want to avoid re-creating the  `useRef()`  initial value.**  For example, maybe you want to ensure some imperative class instance only gets created once:

```jsx
function Image(props) {
  // ⚠️ IntersectionObserver is created on every render
  const ref = useRef(new IntersectionObserver(onIntersect));
  // ...
}
```

`useRef`  **does not**  accept a special function overload like  `useState`. Instead, you can write your own function that creates and sets it lazily:

```jsx
function Image(props) {
  const ref = useRef(null);

  // ✅ IntersectionObserver is created lazily once
  function getObserver() {
    if (ref.current === null) {
      ref.current = new IntersectionObserver(onIntersect);
    }
    return ref.current;
  }

  // When you need it, call getObserver()
  // ...
}
```

This avoids creating an expensive object until it’s truly needed for the first time. If you use Flow or TypeScript, you can also give  `getObserver()`  a non-nullable type for convenience.


## [Lazy initial state]([https://reactjs.org/docs/hooks-reference.html#lazy-initial-state](https://reactjs.org/docs/hooks-reference.html#lazy-initial-state))

The  `initialState`  argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render:

```jsx
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```

## [Is there something like instance variables?]([https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables](https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables))

Yes! The  [`useRef()`](https://reactjs.org/docs/hooks-reference.html#useref)  Hook isn’t just for DOM refs. The “ref” object is a generic container whose  `current`  property is mutable and can hold any value, similar to an instance property on a class.

You can write to it from inside  `useEffect`:

```jsx
function Timer() {
  const intervalRef = useRef();

  useEffect(() => {
    const id = setInterval(() => {
      // ...
    });
    intervalRef.current = id;
    return () => {
      clearInterval(intervalRef.current);
    };
  });

  // ...
}
```

If we just wanted to set an interval, we wouldn’t need the ref (`id`  could be local to the effect), but it’s useful if we want to clear the interval from an event handler:

```jsx
  // ...
  function handleCancelClick() {
    clearInterval(intervalRef.current);
  }
  // ...
```

Conceptually, you can think of refs as similar to instance variables in a class. Unless you’re doing  [lazy initialization](https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily), avoid setting refs during rendering — this can lead to surprising behavior. Instead, typically you want to modify refs in event handlers and effects.



## [Should I use one or many state variables?]([https://reactjs.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables](https://reactjs.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables))

If you’re coming from classes, you might be tempted to always call  `useState()`  once and put all state into a single object. You can do it if you’d like. Here is an example of a component that follows the mouse movement. We keep its position and size in the local state:

```jsx
function Box() {
  const [state, setState] = useState({ left: 0, top: 0, width: 100, height: 100 });
  // ...
}
```

Now let’s say we want to write some logic that changes  `left`  and  `top`  when the user moves their mouse. Note how we have to merge these fields into the previous state object manually:

```jsx
  // ...
  useEffect(() => {
    function handleWindowMouseMove(e) {
      // Spreading "...state" ensures we don't "lose" width and height
      setState(state => ({ ...state, left: e.pageX, top: e.pageY }));
    }
    // Note: this implementation is a bit simplified
    window.addEventListener('mousemove', handleWindowMouseMove);
    return () => window.removeEventListener('mousemove', handleWindowMouseMove);
  }, []);
  // ...
```

This is because when we update a state variable, we  _replace_  its value. This is different from  `this.setState`  in a class, which  _merges_  the updated fields into the object.

If you miss automatic merging, you can write a custom  `useLegacyState`  Hook that merges object state updates. However, instead  **we recommend to split state into multiple state variables based on which values tend to change together.**

For example, we could split our component state into  `position`  and  `size`  objects, and always replace the  `position`  with no need for merging:

```jsx
function Box() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  const [size, setSize] = useState({ width: 100, height: 100 });

  useEffect(() => {
    function handleWindowMouseMove(e) {
      setPosition({ left: e.pageX, top: e.pageY });
    }
    // ...
```

Separating independent state variables also has another benefit. It makes it easy to later extract some related logic into a custom Hook, for example:

```jsx
function Box() {
  const position = useWindowPosition();
  const [size, setSize] = useState({ width: 100, height: 100 });
  // ...
}

function useWindowPosition() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  useEffect(() => {
    // ...
  }, []);
  return position;
}
```

Note how we were able to move the  `useState`  call for the  `position`  state variable and the related effect into a custom Hook without changing their code. If all state was in a single object, extracting it would be more difficult.

Both putting all state in a single  `useState`  call, and having a  `useState`  call per each field can work. Components tend to be most readable when you find a balance between these two extremes, and group related state into a few independent state variables. If the state logic becomes complex, we recommend  [managing it with a reducer](https://reactjs.org/docs/hooks-reference.html#usereducer)  or a custom Hook.)

If you’re coming from classes, you might be tempted to always call  `useState()`  once and put all state into a single object. You can do it if you’d like. Here is an example of a component that follows the mouse movement. We keep its position and size in the local state:

```jsx
function Box() {
  const [state, setState] = useState({ left: 0, top: 0, width: 100, height: 100 });
  // ...
}
```

Now let’s say we want to write some logic that changes  `left`  and  `top`  when the user moves their mouse. Note how we have to merge these fields into the previous state object manually:

```jsx
  // ...
  useEffect(() => {
    function handleWindowMouseMove(e) {
      // Spreading "...state" ensures we don't "lose" width and height
      setState(state => ({ ...state, left: e.pageX, top: e.pageY }));
    }
    // Note: this implementation is a bit simplified
    window.addEventListener('mousemove', handleWindowMouseMove);
    return () => window.removeEventListener('mousemove', handleWindowMouseMove);
  }, []);
  // ...
```

This is because when we update a state variable, we  _replace_  its value. This is different from  `this.setState`  in a class, which  _merges_  the updated fields into the object.

If you miss automatic merging, you can write a custom  `useLegacyState`  Hook that merges object state updates. However, instead  **we recommend to split state into multiple state variables based on which values tend to change together.**

For example, we could split our component state into  `position`  and  `size`  objects, and always replace the  `position`  with no need for merging:

```jsx
function Box() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  const [size, setSize] = useState({ width: 100, height: 100 });

  useEffect(() => {
    function handleWindowMouseMove(e) {
      setPosition({ left: e.pageX, top: e.pageY });
    }
    // ...
```

Separating independent state variables also has another benefit. It makes it easy to later extract some related logic into a custom Hook, for example:

```jsx
function Box() {
  const position = useWindowPosition();
  const [size, setSize] = useState({ width: 100, height: 100 });
  // ...
}

function useWindowPosition() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  useEffect(() => {
    // ...
  }, []);
  return position;
}
```

Note how we were able to move the  `useState`  call for the  `position`  state variable and the related effect into a custom Hook without changing their code. If all state was in a single object, extracting it would be more difficult.

Both putting all state in a single  `useState`  call, and having a  `useState`  call per each field can work. Components tend to be most readable when you find a balance between these two extremes, and group related state into a few independent state variables. If the state logic becomes complex, we recommend  [managing it with a reducer](https://reactjs.org/docs/hooks-reference.html#usereducer)  or a custom Hook.


## "[함수형 컴포넌트와 클래스, 어떤 차이가 존재할까?]([https://overreacted.io/ko/how-are-function-components-different-from-classes/](https://overreacted.io/ko/how-are-function-components-different-from-classes/))" 중..

ref는 고정된 값이 아니기 때문이  _렌더링 도중에_  읽거나 쓰는 것은 피하는 것이 좋다. 렌더링 내에서는 예측 가능한 일들만 일어나는 것이 권장되기 때문이다.  **하지만 특정 prop과 state의 최신값을 불러오고 싶을 때마다 ref를 수동으로 처리하는 것은 내키지 않는다.**  다행히 Hooks의 effect를 이용해 이를 자동화할 수 있다:

```jsx
function MessageThread() {
  const [message, setMessage] = useState('');

  // 최신값을 쫓아간다  const latestMessage = useRef('');  useEffect(() => {    latestMessage.current = message;  });
  const showMessage = () => {
    alert('You said: ' + latestMessage.current);  };
```

([데모](https://codesandbox.io/s/yqmnz7xy8x)를 통해 확인해보자.)

effect 함수  _내부_에 DOM이 업데이트될 때마다 ref 값이 변하도록 설정해줬다. 이렇게 하면 인터럽트 가능한 렌더링에 의존적인  [Time Slicing and Suspense](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html)과 같은 기능들이 값 변경에 의해 피해를 받지 않도록 할 수 있다.

ref를 꼭 사용해야 하는 경우는 많지않다.  **될 수 있으면 props나 state를 고정시키는 것이 좋다.**  하지만 interval이나 subscription 같은[명령형 API](https://overreacted.io/making-setinterval-declarative-with-react-hooks/)다룰 때는 ref가 유용하게 쓰일 수 있다. prop, state, 심지어 함수까지  _어떤_값이던 고정시켜둘 수 있다는 것을 기억하자.

이 패턴은 최적화에도 적합하다(`useCallback`이 자주 바뀐다던지 할 때). 하지만 이럴 때는  [reducer를 쓰는 것](https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down)이 조금  [더 나은 해결책](https://github.com/ryardley/hooks-perf-issues/pull/3)일 수도 있다. (추후 다룰 예정)
